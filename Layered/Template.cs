namespace Layered {

	using System;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.Windows.Forms;

	using Internal;




	/// <summary>Class, that generates <see cref="System.Drawing.Bitmap"/> intended for <see cref="Layered.Theme"/>.</summary>
	/// <seealso cref="System.IDisposable" />
	public sealed class Template : IDisposable {

		/// <summary>Gets the <see cref="System.Drawing.Rectangle"/>, that can be used to create <see cref="Layered.Metrics"/></summary>
		public Rectangle InnerRectangle { get; }

		/// <summary>Gets the <see cref="System.Windows.Forms.Padding"/>, that generated for <see cref="Layered.Theme"/></summary>
		public Padding Margin { get; }

		/// <summary>Gets the <see cref="Layered.Metrics"/></summary>
		public Metrics Metrics { get; }

		/// <summary>Gets the <see cref="Layered.Theme"/></summary>
		public Theme Theme {
			get { return _theme; }
			set {
				_theme = value;
			}
		}

		/// <summary>Gets the <see cref="System.Drawing.Bitmap"/>, generated by constructor.</summary>
		public Bitmap Bitmap {
			get { return _bitmap; }
			set {
				_bitmap = value;
			}
		}

		/// <summary>Gets the <see cref="System.Windows.Forms.Form"/> with which generated <see cref="Layered.Theme"/> can be tested.</summary>
		public Form Form {
			get { return _form; }
			set {
				_form = value;
			}
		}

		private Form _form;
		private Bitmap _bitmap;
		private Theme _theme;




		/// <summary>Default constructor.</summary>
		/// <param name="template"><see cref="System.Drawing.Bitmap"/>, that will be used as a template.</param>
		/// <param name="marginMask"><see cref="System.Drawing.Bitmap"/>, that reprensets a map with two colors (transparent and opaque) and used to determine margin (<see cref="System.Windows.Forms.Padding"/>).</param>
		/// <param name="gradientWidth">Minumum width or height of gradient.</param>
		public Template(Bitmap template, Bitmap marginMask = null, int gradientWidth = 20) {

			// Basicly, we're cutting each fragment from provided template, then triming each
			// side in order to get rid of empty space. After that, we're drawing onto new
			// bitmap those fragments and creating everything we need to launch the test.

			// Provided bitmap must have specific size, so we could divide it onto three parts
			// horizontally and vertically. A little later, we're checking results...
			var width = template.Width / 3;
			var height = template.Height / 3;

			// ...and throwing exception, if something wrong
			if ((width%1) != 0 || (height%1) != 0) {
				throw new Exception($"Width or height of provided bitmap wrong. Width / 3: {width}; Height / 3: {height}");
			}

			// Here we might ignore it, but when updating layered windows, there might be problems.
			if (template.PixelFormat != PixelFormat.Format32bppArgb) {
				throw new Exception("Pixel format of provided bitmap not equals PixelFormat.Format32bppArgb");
			}

			// Creating fragments of corners for horizontal sides
			var hTopLeft = new Fragment(template, new Rectangle(0, 0, width, height), true);
			var hTopRight = new Fragment(template, new Rectangle(width * 2, 0, width, height), true);
			var hBottomLeft = new Fragment(template, new Rectangle(0, height * 2, width, height), true);
			var hBottomRight = new Fragment(template, new Rectangle(width * 2, height * 2, width, height), true);

			// Creating fragments of corners for vertical sides
			var vTopLeft = new Fragment(template, new Rectangle(0, 0, width, height), true);
			var vTopRight = new Fragment(template, new Rectangle(width * 2, 0, width, height), true);
			var vBottomLeft = new Fragment(template, new Rectangle(0, height * 2, width, height), true);
			var vBottomRight = new Fragment(template, new Rectangle(width * 2, height * 2, width, height), true);

			// Creating fragments of sides
			var left = new Fragment(template, new Rectangle(0, height, width, height), true);
			var right = new Fragment(template, new Rectangle(width * 2, height, width, height), true);
			var top = new Fragment(template, new Rectangle(width, 0, width, height), true);
			var bottom = new Fragment(template, new Rectangle(width, height * 2, width, height), true);

			// You can't move several layered windows simultaniusly, even DeferWindowPos fails.
			// But we could create specific mask, that will cover any delays in movement

			// Generating and applying mask to each corner
			hTopLeft.ApplyMask(MaskType.HTopLeft, gradientWidth);
			hTopRight.ApplyMask(MaskType.HTopRight, gradientWidth);
			hBottomLeft.ApplyMask(MaskType.HBottomLeft, gradientWidth);
			hBottomRight.ApplyMask(MaskType.HBottomRight, gradientWidth);

			// ...
			vTopLeft.ApplyMask(MaskType.VTopLeft, gradientWidth);
			vTopRight.ApplyMask(MaskType.VTopRight, gradientWidth);
			vBottomLeft.ApplyMask(MaskType.VBottomLeft, gradientWidth);
			vBottomRight.ApplyMask(MaskType.VBottomRight, gradientWidth);

			// Calculating maximum size of each side. This will be used during scaling sides and
			// creating inner rectangle. Last thing will be used in order to create Metrics.
			var leftSide = Max(vTopLeft.Width, left.Width, vBottomLeft.Width);
			var topSide = Max(vTopLeft.Height, top.Height, vTopRight.Height);
			var rightSide = Max(vTopRight.Width, right.Width, vBottomRight.Width);
			var bottomSide = Max(vBottomLeft.Height, bottom.Height, vBottomRight.Height);

			// Since we're having two types of corners, we need a place for all of them.
			// So, we could scale sides and store 4 corners inside of square.
			left.Scale(0, topSide + bottomSide);
			right.Scale(0, topSide + bottomSide);
			top.Scale(leftSide + bottomSide, 0);
			bottom.Scale(leftSide + bottomSide, 0);

			// Creating bitmap, that will contain all eight corners and four sides
			Bitmap = new Bitmap((leftSide + rightSide) * 2, (topSide + bottomSide) * 2, PixelFormat.Format32bppArgb);

			// Calculating inner rectangle, that will be used as a parameter for Metrics
			InnerRectangle = new Rectangle {
				X = leftSide,
				Y = topSide,
				Width = leftSide + rightSide,
				Height = topSide + bottomSide
			};

			// Metrics contain information about each fragment on bitmap, and we're
			// creating metrics in order to draw each fragment onto bitmap, simple.
			Metrics = new Metrics(Bitmap.Size, InnerRectangle);

			// ...
			using (var g = Graphics.FromImage(Bitmap)) {

				// Sides
				g.DrawImage(top.Bitmap, Metrics.Top, new Rectangle(Point.Empty, top.Size), GraphicsUnit.Pixel);
				g.DrawImage(bottom.Bitmap, Metrics.Bottom, new Rectangle(Point.Empty, bottom.Size), GraphicsUnit.Pixel);
				g.DrawImage(left.Bitmap, Metrics.Left, new Rectangle(Point.Empty, left.Size), GraphicsUnit.Pixel);
				g.DrawImage(right.Bitmap, Metrics.Right, new Rectangle(Point.Empty, right.Size), GraphicsUnit.Pixel);

				// Corners for vertical sides
				g.DrawImage(vTopLeft.Bitmap, Metrics.Vertical.TopLeft, new Rectangle(Point.Empty, vTopLeft.Size), GraphicsUnit.Pixel);
				g.DrawImage(vTopRight.Bitmap, Metrics.Vertical.TopRight, new Rectangle(Point.Empty, vTopRight.Size), GraphicsUnit.Pixel);
				g.DrawImage(vBottomLeft.Bitmap, Metrics.Vertical.BottomLeft, new Rectangle(Point.Empty, vBottomLeft.Size), GraphicsUnit.Pixel);
				g.DrawImage(vBottomRight.Bitmap, Metrics.Vertical.BottomRight, new Rectangle(Point.Empty, vBottomRight.Size), GraphicsUnit.Pixel);

				// Corners for horizontal sides
				g.DrawImage(hTopLeft.Bitmap, Metrics.Horizontal.TopLeft, new Rectangle(Point.Empty, vTopLeft.Size), GraphicsUnit.Pixel);
				g.DrawImage(hTopRight.Bitmap, Metrics.Horizontal.TopRight, new Rectangle(Point.Empty, vTopRight.Size), GraphicsUnit.Pixel);
				g.DrawImage(hBottomLeft.Bitmap, Metrics.Horizontal.BottomLeft, new Rectangle(Point.Empty, vBottomLeft.Size), GraphicsUnit.Pixel);
				g.DrawImage(hBottomRight.Bitmap, Metrics.Horizontal.BottomRight, new Rectangle(Point.Empty, vBottomRight.Size), GraphicsUnit.Pixel);

			}

			// After we're done with creating result-bitmap, we can dispose from each fragment
			hTopLeft.Dispose();
			hTopRight.Dispose();
			hBottomLeft.Dispose();
			hBottomRight.Dispose();

			// ...
			vTopLeft.Dispose();
			vTopRight.Dispose();
			vBottomLeft.Dispose();
			vBottomRight.Dispose();
			
			// ...
			left.Dispose();
			right.Dispose();
			top.Dispose();
			bottom.Dispose();

			// Developer could specify margin manually, but it will take time to get it right.
			// So, instead of manual setup, we're using bitmap, that contains two types of pixels:
			// one pixels are fully transparent (Color.A == 0), the other one opaque (Color.A = 255).
			// Using the same class to cut and trim fragments, we can calculate what we need.
			if (marginMask != null) {

				// Creating fragments from sides (top, bottom, left, right)
				var topBitmap = new Fragment(marginMask, new Rectangle(width, 0, width, height), true);
				var bottomBitmap = new Fragment(marginMask, new Rectangle(width, height*2, width, height), true);
				var leftBitmap = new Fragment(marginMask, new Rectangle(0, height, width, height), true);
				var rightBitmap = new Fragment(marginMask, new Rectangle(width*2, height, width, height), true);

				// ...
				Margin = new Padding(-leftBitmap.Width, -topBitmap.Height, -(rightBitmap.Width + 1), -(bottomBitmap.Height + 1));

				// ...
				topBitmap.Dispose();
				bottomBitmap.Dispose();
				leftBitmap.Dispose();
				rightBitmap.Dispose();

			} else {

				// In this case, bitmap wasn't specified, so, margin will be empty. In this case,
				// developer can open testing form and tweak margin on each side manually.
				Margin = Padding.Empty;

			}

			// Final steps, creating theme and form. From now, developer can test generated
			// bitmap and see, what's wrong and what's not.
			Theme = new Theme(Bitmap, Metrics, Margin);
			Form = new TestingForm(this);

		}




		/// <summary>Returns the maximum value of the provided arguments.</summary>
		/// <param name="a"></param>
		/// <param name="b"></param>
		/// <param name="c"></param>
		/// <returns>Returns the maximum value of the provided arguments.</returns>
		internal static int Max(int a, int b, int c) {
			return Math.Max(a, Math.Max(b, c));
		}




		/// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
		public void Dispose() {
			_theme.Dispose();
			_bitmap.Dispose();
			_form.Dispose();

		}




	}




}
